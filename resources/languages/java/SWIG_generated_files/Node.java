/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.cyberbotics.webots.controller;

public class Node {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  protected Node(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(Node obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        throw new UnsupportedOperationException("C++ destructor does not have public access");
      }
      swigCPtr = 0;
    }
  }

// ----- begin hand written section ----
  public Node getParentNode() {
    long cPtr = wrapperJNI.Node_getParentNodePrivate(swigCPtr, this);
    return Node.findNode(cPtr);
  }

  public Node getFromProtoDef(String name) {
    long cPtr = wrapperJNI.Node_getFromProtoDefPrivate(swigCPtr, this, name);
    return Node.findNode(cPtr);
  }

  public Field getField(String fieldName) {
    long cPtr = wrapperJNI.Node_getFieldPrivate(swigCPtr, this, fieldName);
    return Field.findField(cPtr);
  }

  private static java.util.HashMap<Long,Node> nodes = new java.util.HashMap<Long,Node>();

  // DO NOT USE THIS FUNCTION: IT IS RESERVED FOR INTERNAL USE !
  public static Node findNode(long cPtr) {
    if (cPtr == 0)
      return null;

    Node node = nodes.get(new Long(cPtr));
    if (node != null)
      return node;

    node = new Node(cPtr, false);
    nodes.put(new Long(cPtr), node);
    return node;
  }

  public void remove() {
    wrapperJNI.Node_remove(swigCPtr, this);
  }

  public int getId() {
    return wrapperJNI.Node_getId(swigCPtr, this);
  }

  public int getType() {
    return wrapperJNI.Node_getType(swigCPtr, this);
  }

  public String getDef() {
    return wrapperJNI.Node_getDef(swigCPtr, this);
  }

  public String getTypeName() {
    return wrapperJNI.Node_getTypeName(swigCPtr, this);
  }

  public String getBaseTypeName() {
    return wrapperJNI.Node_getBaseTypeName(swigCPtr, this);
  }

  private Node getParentNodePrivate() {
    long cPtr = wrapperJNI.Node_getParentNodePrivate(swigCPtr, this);
    return (cPtr == 0) ? null : new Node(cPtr, false);
  }

  public boolean isProto() {
    return wrapperJNI.Node_isProto(swigCPtr, this);
  }

  private Node getFromProtoDefPrivate(String name) {
    long cPtr = wrapperJNI.Node_getFromProtoDefPrivate(swigCPtr, this, name);
    return (cPtr == 0) ? null : new Node(cPtr, false);
  }

  private Field getFieldPrivate(String fieldName) {
    long cPtr = wrapperJNI.Node_getFieldPrivate(swigCPtr, this, fieldName);
    return (cPtr == 0) ? null : new Field(cPtr, false);
  }

  public Field getProtoField(String fieldName) {
    long cPtr = wrapperJNI.Node_getProtoField(swigCPtr, this, fieldName);
    return (cPtr == 0) ? null : new Field(cPtr, false);
  }

  public double[] getPosition() {
    return wrapperJNI.Node_getPosition(swigCPtr, this);
  }

  public double[] getOrientation() {
    return wrapperJNI.Node_getOrientation(swigCPtr, this);
  }

  public double[] getCenterOfMass() {
    return wrapperJNI.Node_getCenterOfMass(swigCPtr, this);
  }

  public double[] getContactPoint(int index) {
    return wrapperJNI.Node_getContactPoint(swigCPtr, this, index);
  }

  public int getNumberOfContactPoints() {
    return wrapperJNI.Node_getNumberOfContactPoints(swigCPtr, this);
  }

  public boolean getStaticBalance() {
    return wrapperJNI.Node_getStaticBalance(swigCPtr, this);
  }

  public double[] getVelocity() {
    return wrapperJNI.Node_getVelocity(swigCPtr, this);
  }

  public void setVelocity(double[] velocity) {
    wrapperJNI.Node_setVelocity(swigCPtr, this, velocity);
  }

  public void resetPhysics() {
    wrapperJNI.Node_resetPhysics(swigCPtr, this);
  }

  public void restartController() {
    wrapperJNI.Node_restartController(swigCPtr, this);
  }

  public void moveViewpoint() {
    wrapperJNI.Node_moveViewpoint(swigCPtr, this);
  }

  public void setVisibility(Node from, boolean visible) {
    wrapperJNI.Node_setVisibility(swigCPtr, this, Node.getCPtr(from), from, visible);
  }

  public void addForce(double[] force, boolean relative) {
    wrapperJNI.Node_addForce(swigCPtr, this, force, relative);
  }

  public void addForceWithOffset(double[] force, double[] offset, boolean relative) {
    wrapperJNI.Node_addForceWithOffset(swigCPtr, this, force, offset, relative);
  }

  public void addTorque(double[] torque, boolean relative) {
    wrapperJNI.Node_addTorque(swigCPtr, this, torque, relative);
  }

  // Type 
  public final static int NO_NODE = 0;
  public final static int APPEARANCE = NO_NODE + 1;
  public final static int BACKGROUND = APPEARANCE + 1;
  public final static int BOX = BACKGROUND + 1;
  public final static int CAPSULE = BOX + 1;
  public final static int COLOR = CAPSULE + 1;
  public final static int CONE = COLOR + 1;
  public final static int COORDINATE = CONE + 1;
  public final static int CYLINDER = COORDINATE + 1;
  public final static int DIRECTIONAL_LIGHT = CYLINDER + 1;
  public final static int ELEVATION_GRID = DIRECTIONAL_LIGHT + 1;
  public final static int FOG = ELEVATION_GRID + 1;
  public final static int GROUP = FOG + 1;
  public final static int IMAGE_TEXTURE = GROUP + 1;
  public final static int INDEXED_FACE_SET = IMAGE_TEXTURE + 1;
  public final static int INDEXED_LINE_SET = INDEXED_FACE_SET + 1;
  public final static int MATERIAL = INDEXED_LINE_SET + 1;
  public final static int MESH = MATERIAL + 1;
  public final static int MUSCLE = MESH + 1;
  public final static int NORMAL = MUSCLE + 1;
  public final static int PBR_APPEARANCE = NORMAL + 1;
  public final static int PLANE = PBR_APPEARANCE + 1;
  public final static int POINT_LIGHT = PLANE + 1;
  public final static int POINT_SET = POINT_LIGHT + 1;
  public final static int SHAPE = POINT_SET + 1;
  public final static int SPHERE = SHAPE + 1;
  public final static int SPOT_LIGHT = SPHERE + 1;
  public final static int TEXTURE_COORDINATE = SPOT_LIGHT + 1;
  public final static int TEXTURE_TRANSFORM = TEXTURE_COORDINATE + 1;
  public final static int TRANSFORM = TEXTURE_TRANSFORM + 1;
  public final static int VIEWPOINT = TRANSFORM + 1;
  public final static int ROBOT = VIEWPOINT + 1;
  public final static int DIFFERENTIAL_WHEELS = ROBOT + 1;
  public final static int ACCELEROMETER = DIFFERENTIAL_WHEELS + 1;
  public final static int BRAKE = ACCELEROMETER + 1;
  public final static int CAMERA = BRAKE + 1;
  public final static int COMPASS = CAMERA + 1;
  public final static int CONNECTOR = COMPASS + 1;
  public final static int DISPLAY = CONNECTOR + 1;
  public final static int DISTANCE_SENSOR = DISPLAY + 1;
  public final static int EMITTER = DISTANCE_SENSOR + 1;
  public final static int GPS = EMITTER + 1;
  public final static int GYRO = GPS + 1;
  public final static int INERTIAL_UNIT = GYRO + 1;
  public final static int LED = INERTIAL_UNIT + 1;
  public final static int LIDAR = LED + 1;
  public final static int LIGHT_SENSOR = LIDAR + 1;
  public final static int LINEAR_MOTOR = LIGHT_SENSOR + 1;
  public final static int PEN = LINEAR_MOTOR + 1;
  public final static int POSITION_SENSOR = PEN + 1;
  public final static int PROPELLER = POSITION_SENSOR + 1;
  public final static int RADAR = PROPELLER + 1;
  public final static int RANGE_FINDER = RADAR + 1;
  public final static int RECEIVER = RANGE_FINDER + 1;
  public final static int ROTATIONAL_MOTOR = RECEIVER + 1;
  public final static int SPEAKER = ROTATIONAL_MOTOR + 1;
  public final static int TOUCH_SENSOR = SPEAKER + 1;
  public final static int BALL_JOINT = TOUCH_SENSOR + 1;
  public final static int BALL_JOINT_PARAMETERS = BALL_JOINT + 1;
  public final static int CHARGER = BALL_JOINT_PARAMETERS + 1;
  public final static int CONTACT_PROPERTIES = CHARGER + 1;
  public final static int DAMPING = CONTACT_PROPERTIES + 1;
  public final static int FLUID = DAMPING + 1;
  public final static int FOCUS = FLUID + 1;
  public final static int HINGE_JOINT = FOCUS + 1;
  public final static int HINGE_JOINT_PARAMETERS = HINGE_JOINT + 1;
  public final static int HINGE_2_JOINT = HINGE_JOINT_PARAMETERS + 1;
  public final static int IMMERSION_PROPERTIES = HINGE_2_JOINT + 1;
  public final static int JOINT_PARAMETERS = IMMERSION_PROPERTIES + 1;
  public final static int LENS = JOINT_PARAMETERS + 1;
  public final static int LENS_FLARE = LENS + 1;
  public final static int PHYSICS = LENS_FLARE + 1;
  public final static int RECOGNITION = PHYSICS + 1;
  public final static int SLIDER_JOINT = RECOGNITION + 1;
  public final static int SLOT = SLIDER_JOINT + 1;
  public final static int SOLID = SLOT + 1;
  public final static int SOLID_REFERENCE = SOLID + 1;
  public final static int TRACK = SOLID_REFERENCE + 1;
  public final static int TRACK_WHEEL = TRACK + 1;
  public final static int WORLD_INFO = TRACK_WHEEL + 1;
  public final static int ZOOM = WORLD_INFO + 1;
  public final static int MICROPHONE = ZOOM + 1;
  public final static int RADIO = MICROPHONE + 1;
  public final static int SKIN = RADIO + 1;

}
